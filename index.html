<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Timing Alignment Tool</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        
        .input-section {
            margin-bottom: 30px;
        }
        
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #555;
        }
        
        textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            resize: vertical;
        }
        
        .file-input-wrapper {
            margin-bottom: 20px;
        }
        
        input[type="file"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            background: white;
        }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .output-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid #eee;
        }
        
        #output {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .stats {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        
        .error {
            color: #dc3545;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8d7da;
            border-radius: 4px;
        }
        
        .success {
            color: #155724;
            margin-top: 10px;
            padding: 10px;
            background-color: #d4edda;
            border-radius: 4px;
        }
        
        .alignment-visualization {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .word-aligned {
            background-color: #28a745;
            color: white;
            padding: 2px 4px;
            margin: 1px;
            border-radius: 2px;
            display: inline-block;
        }
        
        .word-inserted {
            background-color: #ffc107;
            color: #333;
            padding: 2px 4px;
            margin: 1px;
            border-radius: 2px;
            display: inline-block;
        }
        
        .word-deleted {
            background-color: #dc3545;
            color: white;
            padding: 2px 4px;
            margin: 1px;
            border-radius: 2px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Word Timing Alignment Tool</h1>
        
        <div class="input-section">
            <label for="timedHtml">Timed Transcript (HTML with data-m and data-d attributes):</label>
            <textarea id="timedHtml" placeholder='Paste HTML like: <p><span data-m="52890" data-d="90">I </span>...</p>'></textarea>
        </div>
        
        <div class="input-section">
            <label for="plainText">Plain Text Transcript (or upload file):</label>
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".txt">
            </div>
            <textarea id="plainText" placeholder="Enter plain text transcript or upload a .txt file"></textarea>
        </div>
        
        <button onclick="alignTranscripts()">Align Transcripts</button>
        <button onclick="clearAll()">Clear All</button>
        
        <div id="errorMessage"></div>
        
        <div class="output-section" id="outputSection" style="display: none;">
            <h2>Aligned Output</h2>
            <div id="alignmentVisualization" class="alignment-visualization"></div>
            <div id="output"></div>
            <div id="stats" class="stats"></div>
        </div>
    </div>

    <script>
        // File input handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('plainText').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });

        // Extract words and timings from HTML
        // This function parses the input HTML and extracts:
        // 1. The text content of each span (the words)
        // 2. The timing attributes (data-m for start time, data-d for duration)
        function extractTimedWords(html) {
            // Use browser's built-in HTML parser
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Find all spans with timing attributes
            // Expected format: <span data-m="52890" data-d="90">I </span>
            const spans = doc.querySelectorAll('span[data-m][data-d]');
            
            const words = [];
            const timings = [];
            
            spans.forEach(span => {
                // Extract and trim the word (removes extra spaces)
                const word = span.textContent.trim();
                if (word) {
                    words.push(word);
                    
                    // Parse timing attributes
                    // data-m: start time in milliseconds
                    // data-d: duration in milliseconds
                    const start = parseInt(span.getAttribute('data-m'));
                    const duration = parseInt(span.getAttribute('data-d'));
                    
                    // Store timing info with calculated end time
                    timings.push({ 
                        start, 
                        duration, 
                        end: start + duration 
                    });
                }
            });
            
            return { words, timings };
        }

        // Simple word alignment using edit distance
        function alignWords(sourceWords, targetWords) {
            const m = sourceWords.length;
            const n = targetWords.length;
            
            // Create DP table
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            
            // Initialize base cases
            for (let i = 0; i <= m; i++) dp[i][0] = i;
            for (let j = 0; j <= n; j++) dp[0][j] = j;
            
            // Fill DP table
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (sourceWords[i-1].toLowerCase() === targetWords[j-1].toLowerCase()) {
                        dp[i][j] = dp[i-1][j-1];
                    } else {
                        dp[i][j] = Math.min(
                            dp[i-1][j-1] + 1,  // substitute
                            dp[i-1][j] + 1,    // delete
                            dp[i][j-1] + 1     // insert
                        );
                    }
                }
            }
            
            // Backtrack to find alignment
            const alignment = [];
            let i = m, j = n;
            
            while (i > 0 || j > 0) {
                if (i === 0) {
                    alignment.push({ type: 'insert', sourceIdx: null, targetIdx: j-1 });
                    j--;
                } else if (j === 0) {
                    alignment.push({ type: 'delete', sourceIdx: i-1, targetIdx: null });
                    i--;
                } else {
                    const current = dp[i][j];
                    if (sourceWords[i-1].toLowerCase() === targetWords[j-1].toLowerCase()) {
                        alignment.push({ type: 'match', sourceIdx: i-1, targetIdx: j-1 });
                        i--;
                        j--;
                    } else if (current === dp[i-1][j-1] + 1) {
                        alignment.push({ type: 'substitute', sourceIdx: i-1, targetIdx: j-1 });
                        i--;
                        j--;
                    } else if (current === dp[i-1][j] + 1) {
                        alignment.push({ type: 'delete', sourceIdx: i-1, targetIdx: null });
                        i--;
                    } else {
                        alignment.push({ type: 'insert', sourceIdx: null, targetIdx: j-1 });
                        j--;
                    }
                }
            }
            
            alignment.reverse();
            return alignment;
        }

        // Main alignment function
        function alignTranscripts() {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = '';
            
            try {
                // Get inputs
                const timedHtml = document.getElementById('timedHtml').value.trim();
                const plainText = document.getElementById('plainText').value.trim();
                
                if (!timedHtml || !plainText) {
                    throw new Error('Please provide both timed HTML and plain text transcript');
                }
                
                // Extract words and timings from HTML
                const { words: sourceWords, timings } = extractTimedWords(timedHtml);
                
                if (sourceWords.length === 0) {
                    throw new Error('No words found in HTML. Make sure spans have data-m and data-d attributes');
                }
                
                // Split plain text into words
                const targetWords = plainText.split(/\s+/).filter(w => w.length > 0);
                
                // Align words
                const alignment = alignWords(sourceWords, targetWords);
                
                // Generate output
                const output = [];
                const alignmentVis = [];
                let lastTiming = null;
                
                alignment.forEach((align, idx) => {
                    if (align.type === 'match' || align.type === 'substitute') {
                        const timing = timings[align.sourceIdx];
                        output.push({
                            word: targetWords[align.targetIdx],
                            start: timing.start,
                            duration: timing.duration
                        });
                        lastTiming = timing;
                        alignmentVis.push({
                            type: 'aligned',
                            source: sourceWords[align.sourceIdx],
                            target: targetWords[align.targetIdx]
                        });
                    } else if (align.type === 'insert') {
                        // Find next timing
                        let nextTiming = null;
                        for (let i = idx + 1; i < alignment.length; i++) {
                            if (alignment[i].type === 'match' || alignment[i].type === 'substitute') {
                                nextTiming = timings[alignment[i].sourceIdx];
                                break;
                            }
                        }
                        
                        // Use next timing, or last timing if no next
                        const timing = nextTiming || lastTiming;
                        if (timing) {
                            output.push({
                                word: targetWords[align.targetIdx],
                                start: timing.start,
                                duration: timing.duration
                            });
                        }
                        alignmentVis.push({
                            type: 'inserted',
                            target: targetWords[align.targetIdx]
                        });
                    } else if (align.type === 'delete') {
                        alignmentVis.push({
                            type: 'deleted',
                            source: sourceWords[align.sourceIdx]
                        });
                    }
                });
                
                // Display results
                displayOutput(output);
                displayAlignment(alignmentVis);
                displayStats(sourceWords.length, targetWords.length, alignment);
                
            } catch (error) {
                errorDiv.innerHTML = `<div class="error">${error.message}</div>`;
            }
        }

        function displayOutput(output) {
            const outputDiv = document.getElementById('output');
            const outputSection = document.getElementById('outputSection');
            
            // Generate HTML output
            let html = '<p>\n';
            output.forEach(item => {
                html += `  <span data-m="${item.start}" data-d="${item.duration}">${item.word} </span>\n`;
            });
            html += '</p>';
            
            outputDiv.textContent = html;
            outputSection.style.display = 'block';
        }

        function displayAlignment(alignmentVis) {
            const visDiv = document.getElementById('alignmentVisualization');
            let html = '<strong>Alignment Visualization:</strong><br>';
            
            alignmentVis.forEach(item => {
                if (item.type === 'aligned') {
                    html += `<span class="word-aligned">${item.source} → ${item.target}</span> `;
                } else if (item.type === 'inserted') {
                    html += `<span class="word-inserted">+ ${item.target}</span> `;
                } else if (item.type === 'deleted') {
                    html += `<span class="word-deleted">- ${item.source}</span> `;
                }
            });
            
            visDiv.innerHTML = html;
        }

        function displayStats(sourceCount, targetCount, alignment) {
            const statsDiv = document.getElementById('stats');
            const matches = alignment.filter(a => a.type === 'match').length;
            const substitutions = alignment.filter(a => a.type === 'substitute').length;
            const insertions = alignment.filter(a => a.type === 'insert').length;
            const deletions = alignment.filter(a => a.type === 'delete').length;
            
            statsDiv.innerHTML = `
                <strong>Alignment Statistics:</strong><br>
                Source words: ${sourceCount}<br>
                Target words: ${targetCount}<br>
                Exact matches: ${matches}<br>
                Substitutions: ${substitutions}<br>
                Insertions: ${insertions}<br>
                Deletions: ${deletions}
            `;
        }

        function clearAll() {
            document.getElementById('timedHtml').value = '';
            document.getElementById('plainText').value = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('outputSection').style.display = 'none';
            document.getElementById('errorMessage').innerHTML = '';
        }
    </script>
</body>
</html>
