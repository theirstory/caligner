<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Timing Alignment Tool</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        
        .input-section {
            margin-bottom: 30px;
        }
        
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #555;
        }
        
        textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            resize: vertical;
        }
        
        .file-input-wrapper {
            margin-bottom: 20px;
        }
        
        input[type="file"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            background: white;
        }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .output-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid #eee;
        }
        
        #output {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .stats {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        
        .error {
            color: #dc3545;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8d7da;
            border-radius: 4px;
        }
        
        .success {
            color: #155724;
            margin-top: 10px;
            padding: 10px;
            background-color: #d4edda;
            border-radius: 4px;
        }
        
        .alignment-visualization {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .word-aligned {
            background-color: #28a745;
            color: white;
            padding: 2px 4px;
            margin: 1px;
            border-radius: 2px;
            display: inline-block;
        }
        
        .word-inserted {
            background-color: #ffc107;
            color: #333;
            padding: 2px 4px;
            margin: 1px;
            border-radius: 2px;
            display: inline-block;
        }
        
        .word-deleted {
            background-color: #dc3545;
            color: white;
            padding: 2px 4px;
            margin: 1px;
            border-radius: 2px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Word Timing Alignment Tool</h1>
        
        <div class="input-section">
            <label for="timedHtml">Timed Transcript (HTML with data-m and data-d attributes):</label>
            <textarea id="timedHtml" placeholder='Paste HTML like: <p><span data-m="52890" data-d="90">I </span>...</p>'></textarea>
        </div>
        
        <div class="input-section">
            <label for="plainText">Plain Text Transcript (or upload file):</label>
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".txt">
            </div>
            <textarea id="plainText" placeholder="Enter plain text transcript or upload a .txt file"></textarea>
        </div>
        
        <button onclick="alignTranscripts()">Align Transcripts</button>
        <button onclick="clearAll()">Clear All</button>
        
        <div id="errorMessage"></div>
        
        <div class="output-section" id="outputSection" style="display: none;">
            <h2>Aligned Output</h2>
            <div id="alignmentVisualization" class="alignment-visualization"></div>
            <div id="output"></div>
            <div id="stats" class="stats"></div>
        </div>
    </div>

    <script>
        // File input handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('plainText').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });

        // Extract words and timings from HTML
        // This function parses the input HTML and extracts:
        // 1. The text content of each span (the words)
        // 2. The timing attributes (data-m for start time, data-d for duration)
        // 3. The original HTML structure
        function extractTimedWords(html) {
            // Use browser's built-in HTML parser
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Find all spans with timing attributes
            // Expected format: <span data-m="52890" data-d="90">I </span>
            const spans = doc.querySelectorAll('span[data-m][data-d]');
            
            const words = [];
            const timings = [];
            
            spans.forEach(span => {
                // Extract and trim the word (removes extra spaces)
                const word = span.textContent.trim();
                if (word) {
                    words.push(word);
                    
                    // Parse timing attributes
                    // data-m: start time in milliseconds
                    // data-d: duration in milliseconds
                    const start = parseInt(span.getAttribute('data-m'));
                    const duration = parseInt(span.getAttribute('data-d'));
                    
                    // Store timing info with calculated end time
                    timings.push({ 
                        start, 
                        duration, 
                        end: start + duration 
                    });
                }
            });
            
            // Preserve the original HTML structure
            const htmlStructure = html.trim();
            
            return { words, timings, htmlStructure };
        }

        // Helper function to strip punctuation from word endings
        // This ensures "minute," matches with "minute" and "happen." matches with "happen"
        function stripPunctuation(word) {
            // Remove common punctuation from the end of words
            // This regex matches one or more punctuation characters at the end of the string
            return word.replace(/[.,!?;:'"]+$/, '');
        }
        
        // Helper function to normalize word for comparison (lowercase + strip punctuation)
        // This ensures "Minute," matches with "minute" and "HAPPEN." matches with "happen"
        function normalizeWord(word) {
            return stripPunctuation(word.toLowerCase());
        }

        // Better word alignment that handles reordering and substitutions
        // This algorithm finds the best mapping between source words (with timings) 
        // and target words (corrected transcript)
        function alignWords(sourceWords, targetWords) {
            // STEP 1: CREATE WORD FREQUENCY MAPS
            // These maps help us handle duplicate words and find all occurrences
            // Example: "the" might appear multiple times in both transcripts
            const sourceWordMap = new Map();  // word -> [index1, index2, ...]
            const targetWordMap = new Map();  // word -> [index1, index2, ...]
            
            // Build frequency maps (using normalized words for comparison)
            // Source example: ["I", "think", "Minute,"] 
            // Creates map: {"i" -> [0], "think" -> [1], "minute" -> [2]}
            sourceWords.forEach((word, idx) => {
                const key = normalizeWord(word);  // Lowercase + strip punctuation
                if (!sourceWordMap.has(key)) {
                    sourceWordMap.set(key, []);
                }
                sourceWordMap.get(key).push(idx);
            });
            
            targetWords.forEach((word, idx) => {
                const key = normalizeWord(word);  // Lowercase + strip punctuation
                if (!targetWordMap.has(key)) {
                    targetWordMap.set(key, []);
                }
                targetWordMap.get(key).push(idx);
            });
            
            // STEP 2: TRACK ALIGNMENT STATE
            const usedSourceIndices = new Set();  // Which source words we've already matched
            const targetAlignment = new Array(targetWords.length).fill(null);  // Maps target index -> source index
            
            // STEP 3: FIRST PASS - IN-ORDER MATCHING WITH CONTEXT AWARENESS
            // This pass tries to maintain word order when possible
            // For repeated words, we use context to choose the best match
            //
            // Visual example:
            // Source: "The Hyperaudio Lite Editor... is Hyperaudio Lite"
            // Target: "The Hyperaudio Lite Editor... is Hyperaudio Lite"
            //         
            // Should match first "Hyperaudio Lite" to first occurrence, not last
            let lastSourceIdx = -1;  // Tracks the last matched source position
            
            for (let targetIdx = 0; targetIdx < targetWords.length; targetIdx++) {
                const targetWord = normalizeWord(targetWords[targetIdx]);  // Normalize for comparison
                
                if (sourceWordMap.has(targetWord)) {
                    const sourceIndices = sourceWordMap.get(targetWord);
                    
                    // For repeated words, use context to find best match
                    let bestSourceIdx = null;
                    let bestScore = -1;
                    
                    for (const sourceIdx of sourceIndices) {
                        if (!usedSourceIndices.has(sourceIdx)) {
                            // Calculate a score based on:
                            // 1. Maintaining order (prefer indices after lastSourceIdx)
                            // 2. Context similarity (check surrounding words)
                            let score = 0;
                            
                            // Order score: prefer maintaining sequence
                            if (sourceIdx > lastSourceIdx) {
                                score += 100; // High bonus for maintaining order
                            }
                            
                            // Context score: check if surrounding words match
                            // Check previous word
                            if (targetIdx > 0 && sourceIdx > 0) {
                                const prevTarget = normalizeWord(targetWords[targetIdx - 1]);
                                const prevSource = normalizeWord(sourceWords[sourceIdx - 1]);
                                if (prevTarget === prevSource) {
                                    score += 50;
                                }
                            }
                            
                            // Check next word
                            if (targetIdx < targetWords.length - 1 && sourceIdx < sourceWords.length - 1) {
                                const nextTarget = normalizeWord(targetWords[targetIdx + 1]);
                                const nextSource = normalizeWord(sourceWords[sourceIdx + 1]);
                                if (nextTarget === nextSource) {
                                    score += 50;
                                }
                            }
                            
                            // Distance penalty: prefer closer positions
                            const expectedPosition = lastSourceIdx + 1;
                            const distance = Math.abs(sourceIdx - expectedPosition);
                            score -= distance * 2;
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestSourceIdx = sourceIdx;
                            }
                        }
                    }
                    
                    if (bestSourceIdx !== null) {
                        targetAlignment[targetIdx] = bestSourceIdx;
                        usedSourceIndices.add(bestSourceIdx);
                        lastSourceIdx = bestSourceIdx;
                    }
                }
            }
            
            // STEP 4: SECOND PASS - OUT-OF-ORDER MATCHING
            // This handles words that moved positions in the sentence
            // Example: "unfortunately" might have moved from position 2 to position 4
            //
            // Visual example after Pass 1:
            // Target: "So I think that unfortunately the minute"
            //         X  ✓   ✓    X      ?       ✓    ✓
            //
            // Pass 2 will now match: unfortunately->unfortunately (out of order)
            for (let targetIdx = 0; targetIdx < targetWords.length; targetIdx++) {
                if (targetAlignment[targetIdx] === null) {  // Not matched in first pass
                    const targetWord = normalizeWord(targetWords[targetIdx]);  // Normalize for comparison
                    
                    if (sourceWordMap.has(targetWord)) {
                        const sourceIndices = sourceWordMap.get(targetWord);
                        
                        // Find any unused source index (order doesn't matter now)
                        for (const sourceIdx of sourceIndices) {
                            if (!usedSourceIndices.has(sourceIdx)) {
                                targetAlignment[targetIdx] = sourceIdx;
                                usedSourceIndices.add(sourceIdx);
                                break;
                            }
                        }
                    }
                }
            }
            
            // STEP 5: HANDLE SUBSTITUTION GROUPS
            // Find groups of consecutive unmatched words that might be substitutions
            // Example: "people aware" -> "sheep a bear" should be treated as a substitution group
            const substitutionGroups = [];
            let currentUnmatchedGroup = [];
            
            for (let targetIdx = 0; targetIdx < targetWords.length; targetIdx++) {
                if (targetAlignment[targetIdx] === null) {
                    currentUnmatchedGroup.push(targetIdx);
                } else {
                    if (currentUnmatchedGroup.length > 0) {
                        substitutionGroups.push([...currentUnmatchedGroup]);
                        currentUnmatchedGroup = [];
                    }
                }
            }
            if (currentUnmatchedGroup.length > 0) {
                substitutionGroups.push(currentUnmatchedGroup);
            }
            
            // For each substitution group, find nearby unused source words
            substitutionGroups.forEach(group => {
                // Find the context (previous and next matched words)
                let prevMatchedIdx = -1;
                let nextMatchedIdx = targetWords.length;
                
                for (let i = group[0] - 1; i >= 0; i--) {
                    if (targetAlignment[i] !== null) {
                        prevMatchedIdx = targetAlignment[i];
                        break;
                    }
                }
                
                for (let i = group[group.length - 1] + 1; i < targetWords.length; i++) {
                    if (targetAlignment[i] !== null) {
                        nextMatchedIdx = targetAlignment[i];
                        break;
                    }
                }
                
                // Find unused source words in the range
                const unusedInRange = [];
                for (let sourceIdx = prevMatchedIdx + 1; sourceIdx < nextMatchedIdx && sourceIdx < sourceWords.length; sourceIdx++) {
                    if (!usedSourceIndices.has(sourceIdx)) {
                        unusedInRange.push(sourceIdx);
                    }
                }
                
                // Map the substitution group to the unused source words
                if (unusedInRange.length > 0) {
                    // Case 1: Same number of words - one-to-one mapping
                    if (unusedInRange.length === group.length) {
                        for (let i = 0; i < group.length; i++) {
                            targetAlignment[group[i]] = unusedInRange[i];
                            usedSourceIndices.add(unusedInRange[i]);
                        }
                    }
                    // Case 2: Fewer target words than source - skip some source timings
                    else if (unusedInRange.length > group.length) {
                        for (let i = 0; i < group.length; i++) {
                            targetAlignment[group[i]] = unusedInRange[i];
                            usedSourceIndices.add(unusedInRange[i]);
                        }
                    }
                    // Case 3: More target words than source - reuse timings
                    else {
                        for (let i = 0; i < group.length; i++) {
                            const sourceIdx = unusedInRange[Math.min(i, unusedInRange.length - 1)];
                            targetAlignment[group[i]] = sourceIdx;
                            // Don't mark as used if we're reusing it
                            if (i < unusedInRange.length) {
                                usedSourceIndices.add(sourceIdx);
                            }
                        }
                    }
                }
            });
            
            // STEP 6: BUILD FINAL ALIGNMENT STRUCTURE
            // Convert our mapping into a list of alignment operations
            const alignment = [];
            
            // Add all matched and inserted words
            // Each target word is either:
            // - Matched to a source word (has timing)
            // - Inserted (new word, needs interpolated timing)
            for (let targetIdx = 0; targetIdx < targetWords.length; targetIdx++) {
                const sourceIdx = targetAlignment[targetIdx];
                if (sourceIdx !== null) {
                    alignment.push({ 
                        type: 'match', 
                        sourceIdx: sourceIdx, 
                        targetIdx: targetIdx 
                    });
                } else {
                    alignment.push({ 
                        type: 'insert', 
                        sourceIdx: null, 
                        targetIdx: targetIdx 
                    });
                }
            }
            
            // Add deleted words (words in source but not in target)
            // Example: "at" appears in source but not in corrected transcript
            for (let sourceIdx = 0; sourceIdx < sourceWords.length; sourceIdx++) {
                if (!usedSourceIndices.has(sourceIdx)) {
                    alignment.push({ 
                        type: 'delete', 
                        sourceIdx: sourceIdx, 
                        targetIdx: null 
                    });
                }
            }
            
            // Sort alignment by target index (with deletes at the end)
            // This ensures we process the alignment in the order of the target transcript
            alignment.sort((a, b) => {
                if (a.targetIdx === null) return 1;   // Deletes go to end
                if (b.targetIdx === null) return -1;  // Deletes go to end
                return a.targetIdx - b.targetIdx;     // Others sorted by target position
            });
            
            return alignment;
        }

        // Main alignment function
        function alignTranscripts() {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = '';
            
            try {
                // Get inputs
                const timedHtml = document.getElementById('timedHtml').value.trim();
                const plainText = document.getElementById('plainText').value.trim();
                
                if (!timedHtml || !plainText) {
                    throw new Error('Please provide both timed HTML and plain text transcript');
                }
                
                // Extract words and timings from HTML
                const { words: sourceWords, timings, htmlStructure } = extractTimedWords(timedHtml);
                
                if (sourceWords.length === 0) {
                    throw new Error('No words found in HTML. Make sure spans have data-m and data-d attributes');
                }
                
                // Split plain text into words
                const targetWords = plainText.split(/\s+/).filter(w => w.length > 0);
                
                // Align words
                const alignment = alignWords(sourceWords, targetWords);
                
                // Main alignment flow:
                // 1. Get alignment mapping between source and target words
                // 2. Process each alignment operation to build output
                // The output array will contain {word, start, duration} for each target word
                const output = [];
                
                // Visual representation of the alignment process:
                //
                // Source: [I] [think] [unfortunately] [at] [the] [minute,] [we] ...
                //          0     1           2         3     4       5       6
                //          ↓     ↓           ↓         X     ↓       ↓       ↓
                // Target: [So] [I] [think] [that] [unfortunately] [the] [minute] [we] ...
                //
                // Where: ↓ = match, X = delete, [So] and [that] = inserts
                
                const alignmentVis = [];
                let lastTiming = null;  // Track last timing for interpolation
                
                alignment.forEach((align, idx) => {
                    if (align.type === 'match') {
                        // Direct match: copy timing from source word
                        const timing = timings[align.sourceIdx];
                        output.push({
                            word: targetWords[align.targetIdx],
                            start: timing.start,
                            duration: timing.duration
                        });
                        lastTiming = timing;
                        alignmentVis.push({
                            type: 'aligned',
                            source: sourceWords[align.sourceIdx],
                            target: targetWords[align.targetIdx],
                            sourceIdx: align.sourceIdx
                        });
                    } else if (align.type === 'insert') {
                        // Inserted word: needs timing interpolation
                        // Strategy: Use timing of the next matched word
                        
                        // Find next timing by looking ahead in the alignment
                        let nextTiming = null;
                        for (let i = idx + 1; i < alignment.length; i++) {
                            if (alignment[i].type === 'match') {
                                nextTiming = timings[alignment[i].sourceIdx];
                                break;
                            }
                        }
                        
                        // Use next timing if available, otherwise use last timing
                        // This follows the requirement: "assign the timing of the word that comes after it"
                        const timing = nextTiming || lastTiming;
                        if (timing) {
                            output.push({
                                word: targetWords[align.targetIdx],
                                start: timing.start,
                                duration: timing.duration
                            });
                        }
                        alignmentVis.push({
                            type: 'inserted',
                            target: targetWords[align.targetIdx]
                        });
                    } else if (align.type === 'delete') {
                        // Deleted word: only add to visualization, no output timing needed
                        alignmentVis.push({
                            type: 'deleted',
                            source: sourceWords[align.sourceIdx]
                        });
                    }
                });
                
                // Display results
                displayOutput(output, htmlStructure);
                displayAlignment(alignmentVis);
                displayStats(sourceWords.length, targetWords.length, alignment);
                
            } catch (error) {
                errorDiv.innerHTML = `<div class="error">${error.message}</div>`;
            }
        }

        function displayOutput(output, originalHtml) {
            const outputDiv = document.getElementById('output');
            const outputSection = document.getElementById('outputSection');
            
            // Parse the original HTML to preserve structure
            const parser = new DOMParser();
            const doc = parser.parseFromString(originalHtml, 'text/html');
            
            // Generate spans HTML
            let spansHtml = '';
            output.forEach(item => {
                spansHtml += `<span data-m="${item.start}" data-d="${item.duration}">${item.word} </span>`;
            });
            
            // Find all <p> tags and replace their content
            const pTags = doc.querySelectorAll('p');
            if (pTags.length > 0) {
                // Replace content of first p tag with our new spans
                pTags[0].innerHTML = spansHtml;
                // Output just the modified p tag, not the entire body
                outputDiv.textContent = pTags[0].outerHTML;
            } else {
                // If no p tags found, wrap in p tags
                outputDiv.textContent = `<p>${spansHtml}</p>`;
            }
            
            outputSection.style.display = 'block';
        }

        function displayAlignment(alignmentVis) {
            const visDiv = document.getElementById('alignmentVisualization');
            let html = '<strong>Alignment Visualization:</strong><br>';
            
            alignmentVis.forEach(item => {
                if (item.type === 'aligned') {
                    html += `<span class="word-aligned">${item.source}[${item.sourceIdx}] → ${item.target}</span> `;
                } else if (item.type === 'inserted') {
                    html += `<span class="word-inserted">+ ${item.target}</span> `;
                } else if (item.type === 'deleted') {
                    html += `<span class="word-deleted">- ${item.source}</span> `;
                }
            });
            
            visDiv.innerHTML = html;
        }

        function displayStats(sourceCount, targetCount, alignment) {
            const statsDiv = document.getElementById('stats');
            const matches = alignment.filter(a => a.type === 'match').length;
            const substitutions = alignment.filter(a => a.type === 'substitute').length;
            const insertions = alignment.filter(a => a.type === 'insert').length;
            const deletions = alignment.filter(a => a.type === 'delete').length;
            
            statsDiv.innerHTML = `
                <strong>Alignment Statistics:</strong><br>
                Source words: ${sourceCount}<br>
                Target words: ${targetCount}<br>
                Exact matches: ${matches}<br>
                Substitutions: ${substitutions}<br>
                Insertions: ${insertions}<br>
                Deletions: ${deletions}
            `;
        }

        function clearAll() {
            document.getElementById('timedHtml').value = '';
            document.getElementById('plainText').value = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('outputSection').style.display = 'none';
            document.getElementById('errorMessage').innerHTML = '';
        }
    </script>
</body>
</html>
